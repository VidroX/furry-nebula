package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	generalErrors "github.com/VidroX/furry-nebula/errors/general"
	"github.com/VidroX/furry-nebula/errors/validation"
	"github.com/VidroX/furry-nebula/graph"
	"github.com/VidroX/furry-nebula/graph/model"
	"github.com/VidroX/furry-nebula/services/database"
	"github.com/VidroX/furry-nebula/services/translator"
)

// AddShelter is the resolver for the addShelter field.
func (r *mutationResolver) AddShelter(ctx context.Context, data model.ShelterInput, photo *graphql.Upload) (*model.Shelter, error) {
	gCtx := graph.GetGinContext(ctx)
	shelterService := gCtx.GetServices().ShelterService
	user, err := gCtx.RequireUser(model.TokenTypeAccess)

	if err != nil {
		return nil, graph.FormatError(gCtx.GetLocalizer(), err)
	}

	if photo != nil && !graph.IsImageTypeSupported(photo.ContentType) {
		return nil, graph.FormatError(
			gCtx.GetLocalizer(),
			validation.ConstructValidationError(validation.ErrInvalidFileFormat, "photo"),
		)
	}

	shelter, errors := shelterService.AddShelter(user.ID, data)

	if errors != nil && len(errors) > 0 {
		graph.ProcessErrorsSlice(&ctx, gCtx.GetLocalizer(), errors)

		return nil, nil
	}

	if photo != nil {
		fPath, _ := graph.ProcessGraphPhotoUpload(gCtx, user, photo)
		_ = shelterService.UpdateShelterPhoto(user.ID, shelter.ID, fPath)

		shelter.Photo = fPath
	}

	return shelter, nil
}

// AddShelterAnimal is the resolver for the addShelterAnimal field.
func (r *mutationResolver) AddShelterAnimal(ctx context.Context, data model.ShelterAnimalInput, photo *graphql.Upload) (*model.ShelterAnimal, error) {
	gCtx := graph.GetGinContext(ctx)
	shelterService := gCtx.GetServices().ShelterService
	user, err := gCtx.RequireUser(model.TokenTypeAccess)

	if err != nil {
		return nil, graph.FormatError(gCtx.GetLocalizer(), err)
	}

	if photo != nil && !graph.IsImageTypeSupported(photo.ContentType) {
		return nil, graph.FormatError(
			gCtx.GetLocalizer(),
			validation.ConstructValidationError(validation.ErrInvalidFileFormat, "photo"),
		)
	}

	shelterAnimal, errors := shelterService.AddShelterAnimal(user.ID, data)

	if errors != nil && len(errors) > 0 {
		graph.ProcessErrorsSlice(&ctx, gCtx.GetLocalizer(), errors)

		return nil, nil
	}

	if photo != nil {
		fPath, _ := graph.ProcessGraphPhotoUpload(gCtx, user, photo)
		_ = shelterService.UpdateShelterPhoto(user.ID, shelterAnimal.ID, fPath)

		shelterAnimal.Photo = fPath
	}

	return shelterAnimal, nil
}

// DeleteShelter is the resolver for the deleteShelter field.
func (r *mutationResolver) DeleteShelter(ctx context.Context, id string) (*model.ResponseMessage, error) {
	gCtx := graph.GetGinContext(ctx)
	shelterService := gCtx.GetServices().ShelterService
	user, err := gCtx.RequireUser(model.TokenTypeAccess)

	if err != nil {
		return nil, graph.FormatError(gCtx.GetLocalizer(), err)
	}

	err = shelterService.DeleteShelter(user.ID, id)

	if err != nil {
		return nil, graph.FormatError(gCtx.GetLocalizer(), err)
	}

	return &model.ResponseMessage{
		Message: translator.WithKey(translator.KeysShelterServiceShelterRemoved).Translate(gCtx.GetLocalizer()),
	}, nil
}

// RemoveAnimal is the resolver for the removeAnimal field.
func (r *mutationResolver) RemoveAnimal(ctx context.Context, id string) (*model.ResponseMessage, error) {
	gCtx := graph.GetGinContext(ctx)
	shelterService := gCtx.GetServices().ShelterService
	user, err := gCtx.RequireUser(model.TokenTypeAccess)

	if err != nil {
		return nil, graph.FormatError(gCtx.GetLocalizer(), err)
	}

	err = shelterService.RemoveShelterAnimal(user.ID, id)

	if err != nil {
		return nil, graph.FormatError(gCtx.GetLocalizer(), err)
	}

	return &model.ResponseMessage{
		Message: translator.WithKey(translator.KeysShelterServiceShelterAnimalRemoved).Translate(gCtx.GetLocalizer()),
	}, nil
}

// UpdateAnimalRating is the resolver for the updateAnimalRating field.
func (r *mutationResolver) UpdateAnimalRating(ctx context.Context, id string, rating float64) (*model.ShelterAnimal, error) {
	panic(fmt.Errorf("not implemented: UpdateAnimalRating - updateAnimalRating"))
}

// Shelters is the resolver for the shelters field.
func (r *queryResolver) Shelters(ctx context.Context, filters *model.ShelterFilters, pagination *model.Pagination) (*model.ShelterConnection, error) {
	gCtx := graph.GetGinContext(ctx)
	shelterRepo := gCtx.GetRepositories().ShelterRepository
	user, err := gCtx.RequireUser(model.TokenTypeAccess)

	if err != nil {
		return nil, graph.FormatError(gCtx.GetLocalizer(), err)
	}

	shelters, total, err2 := shelterRepo.GetShelters(user, filters, pagination)

	if err2 != nil {
		return nil, graph.FormatError(gCtx.GetLocalizer(), &generalErrors.ErrInternal)
	}

	return &model.ShelterConnection{
		Node:     shelters,
		PageInfo: database.GetPageInfo(total, pagination),
	}, nil
}

// ShelterAnimals is the resolver for the shelterAnimals field.
func (r *queryResolver) ShelterAnimals(ctx context.Context, filters *model.AnimalFilters, pagination *model.Pagination) (*model.ShelterAnimalConnection, error) {
	gCtx := graph.GetGinContext(ctx)
	shelterRepo := gCtx.GetRepositories().ShelterRepository

	shelterAnimals, total, err := shelterRepo.GetShelterAnimals(filters, pagination)

	if err != nil {
		return nil, graph.FormatError(gCtx.GetLocalizer(), &generalErrors.ErrInternal)
	}

	return &model.ShelterAnimalConnection{
		Node:     shelterAnimals,
		PageInfo: database.GetPageInfo(total, pagination),
	}, nil
}

// Shelter is the resolver for the shelter field.
func (r *queryResolver) Shelter(ctx context.Context, id string) (*model.Shelter, error) {
	gCtx := graph.GetGinContext(ctx)
	shelterRepo := gCtx.GetRepositories().ShelterRepository

	shelter, err := shelterRepo.GetShelterById(id)

	if err != nil {
		return nil, graph.FormatError(
			gCtx.GetLocalizer(),
			validation.ConstructValidationError(validation.ErrShelterNotFound, "id"),
		)
	}

	if shelter == nil || shelter.Deleted {
		return nil, graph.FormatError(
			gCtx.GetLocalizer(),
			validation.ConstructValidationError(validation.ErrShelterNotFound, "id"),
		)
	}

	return shelter, nil
}

// ShelterAnimal is the resolver for the shelterAnimal field.
func (r *queryResolver) ShelterAnimal(ctx context.Context, id string) (*model.ShelterAnimal, error) {
	gCtx := graph.GetGinContext(ctx)
	shelterRepo := gCtx.GetRepositories().ShelterRepository

	shelterAnimal, err := shelterRepo.GetShelterAnimalById(id)

	if err != nil {
		return nil, graph.FormatError(
			gCtx.GetLocalizer(),
			validation.ConstructValidationError(validation.ErrShelterAnimalNotFound, "id"),
		)
	}

	if shelterAnimal == nil || shelterAnimal.Removed {
		return nil, graph.FormatError(
			gCtx.GetLocalizer(),
			validation.ConstructValidationError(validation.ErrShelterAnimalNotFound, "id"),
		)
	}

	return shelterAnimal, nil
}

// Animal is the resolver for the animal field.
func (r *shelterAnimalResolver) Animal(ctx context.Context, obj *model.ShelterAnimal) (model.Animal, error) {
	gCtx := graph.GetGinContext(ctx)
	animalType := model.Animal(obj.AnimalType)

	var err error
	if !animalType.IsValid() {
		err = graph.FormatError(gCtx.GetLocalizer(), &generalErrors.ErrInternal)
	}

	return animalType, err
}

// OverallRating is the resolver for the overallRating field.
func (r *shelterAnimalResolver) OverallRating(ctx context.Context, obj *model.ShelterAnimal) (float64, error) {
	// TODO: implement rating logic when ready
	return 0, nil
}

// UserRating is the resolver for the userRating field.
func (r *shelterAnimalResolver) UserRating(ctx context.Context, obj *model.ShelterAnimal) (*float64, error) {
	// TODO: implement rating logic when ready
	return nil, nil
}

// ShelterAnimal returns graph.ShelterAnimalResolver implementation.
func (r *Resolver) ShelterAnimal() graph.ShelterAnimalResolver { return &shelterAnimalResolver{r} }

type shelterAnimalResolver struct{ *Resolver }
